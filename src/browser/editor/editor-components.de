# dom cursor
type Cursor(
    row, col,
    element,
    parent
)

impl new(self) for Cursor {
    self.row = self.col = 1
    self.element = $("span").new().setClass("cursor").setHtml("&nbsp;")
    self.parent = null
}

impl str(self) for Cursor {
    return "\(self.row):\(self.col)"
}

impl detach(self) for Cursor {
     if self.parent /= null {
         self.parent.setClass("")
         self.parent.detach(self.element)
     }
}

impl render(self, references) for Cursor {
    @line = references.get(self.row)
    line.attach(self.element)
    line.setClass("selected")
    self.parent = line
    self.element.setStyle("left", "\(9.906 * self.col)px")
}

impl move(self, row, col) for Cursor {
    if row /= null {
        self.row = row
    }
    if col /= null {
        self.col = col
    }
    return self
}

impl shift(self, row, col) for Cursor {
    if row == null {
        row = 0
    }
    if col == null {
        col = 0
    }
    return self.move(self.row + row, self.col + col)
}

impl snap(self, content) for Cursor {
    self.col = content.get(self.row).size()+1
    return self
}


STATUS_LESS = -1
STATUS_OK = 0
STATUS_MORE = 1
impl rowStatus(self, content) for Cursor {
    @rows = content.size()
    @status = list()
    if self.row <= 1 {
        status.add(STATUS_LESS)
    }
    if self.row >= rows {
        status.add(STATUS_MORE)
    }
    status.add(STATUS_OK)
    return status
}

impl colStatus(self, content) for Cursor {
    @cols = content.get(self.row).size()
    @status = list()
    if self.col <= 1 {
        status.add(STATUS_LESS)
    }
    if self.col >= cols {
        status.add(STATUS_MORE)
    }
    status.add(STATUS_OK)
    return status
}

type TextArea(root, content, references, _lineNumbers, _lines)

impl new(self, root) for TextArea {
    $textArea = $("div").new()
    $textArea.setClass("editor-area").setAttr("tabindex", "-1")
    root.attach $textArea
    self.root = $textArea

    self.content = list("")
    self.references = list(null)

    $lineNumbers = $("div").new()
    $lineNumbers.setClass("editor-linenum")
    $textArea.attach($lineNumbers)
    self._lineNumbers = $lineNumbers

    $lines = $("div").new()
    $lines.setClass "editor-textarea"
    $textArea.attach($lines)
    self._lines = $lines
}

ADD = 0
REPLACE = 1
REMOVE = 2
type Change(line, way)

impl render(self, change) for TextArea {
    self.renderNumbers(change)

    if change /= null {
        match change.way {
            case ADD {
                @newLine = $("div").new()
                newLine.setHtml(self.renderLine(change.line))
                self._lines.insert(change.line, newLine)
                self.references.insert(change.line, newLine)
            }
            case REPLACE {
                @line = self.references.get(change.line)
                line.clear()
                line.setHtml(self.renderLine(change.line))
                self._lines.set(change.line, newLine)
            }
            case REMOVE {
                self.references.remove(change.line)
                self._lines.remove(change.line)
            }
        }
        return
    }

    self._lines.clear()

    @html = list()
    @size = self.content.size()
    for @row = 1; row <= size; row++ {
        html.add("<div>\(self.renderLine(row))</div>")
    }
    self._lines.setHtml(html.join(""))
    self.references = self._lines.children()
}

impl renderNumbers(self, change) for TextArea {
    @lastLine = self.content.size().str().size()
    if change /= null {
        match change.way {
            case ADD {
                @row = change.line
                @lineNumber = $("div").new().setHtml("&nbsp;" * (lastLine-row.str().size()) + row.str())
                self._lineNumbers.insert(row, lineNumber)
            }
            case REMOVE {
                self._lineNumbers.remove(change.line)
            }
        }
        return
    }

    self._lineNumbers.clear()

    @size = self.content.size()
    @out = list()
    for @row = 1; row <= size; row++ {
        out.add("<div>\("&nbsp;" * (lastLine-row.str().size()))\(row)</div>")
    }
    self._lineNumbers.setHtml(out.join(""))
}

impl renderLine(self, lineNumber: Num) for TextArea {
    @line = self.content.get(lineNumber)
    @out = list()
    @size = line.size()
    @start = true
    for @i = 1; i <= size; {
        @c = line.get(i)
        if c == " " {
            @count = 1
            i++
            while i <= size {
                if line.get(i) /= " " {
                    break
                }
                count++
                i++
                if count == 4 {
                    count = 0
                    if start {
                        out.add("<span class=\"re-tab\">\("&nbsp;" * 4)</span>")
                    } else {
                        out.add("<span>\("&nbsp;" * 4)</span>")
                    }
                }
            }
            if count > 0 {
                out.add("<span>\("&nbsp;" * count)</span>")
            }
            start = false
            continue
        }
        start = false
        if bindings.IsVariableHead(c) {
            @word = c
            i++
            while i <= size {
                c = line.get(i)
                if not bindings.IsVariableRest(c) {
                    break
                }
                word = word + c
                i++
            }
            out.add("<span>\(word)</span>")
            continue
        }

        out.add("<span>\(c)</span>")
        i++
    }
    return out.join("")
}

impl highlight(self, change) for TextArea {
    @regions = bindings.Highlight(self.raw())
    if regions == null {
        self.showError()
        return
    }

    each region of regions {
        # random threshold for error because I am very lazy
        if change /= null and (change.line - region.info.row+1).abs() > 3 {
            continue
        }
        @row = self.references.get(region.info.row+1)
        @children = row.children()
        @count = 0
        each child of children {
            @size = child.text().size()
            count = count + size
            if region.info.col == count {
                 child.setStyle("color", region.color)
                 break
            }
            if region.info.col > count and region.info.col - region.info.length <= count - size {
                 child.setStyle("color", region.color)
            }
        }
    }
}

impl raw(self) for TextArea {
    return self.content.join("\n")
}

impl showError(self) for TextArea {
    @problems = bindings.Errors(self.raw())
    each problem of problems {
        @line = self.references.get(problem.info.row+1)
        @children = line.children()
        each child, i of children.reverse() {
            if child.class() == "error" or child.class() == "underline" {
                return
            }
        }
        @banner = $("span").new().setClass("error").setText("[\(problem.code)] \(problem.message.capitalize())")
        line.attach(banner)
        @underline = $("span").new().setClass("underline").setHtml("&nbsp;" * problem.info.length)
        underline.setStyle("left", "\(9.906 * (problem.info.col - problem.info.length + 1))px")
        line.attach(underline)
    }
}

impl updateLine(self, row, newLine, highlight) for TextArea {
    if row > self.content.size() {
        self.content.add(newLine)
        self.update(Change(row, ADD), highlight)
    } else {
        self.content.set(row, newLine)
        self.update(Change(row, REPLACE), highlight)
    }
}

impl insertLine(self, row, newLine, highlight) for TextArea {
    self.content.insert(row, newLine)
    self.update(Change(row, ADD), highlight)
}

impl removeLine(self, row, highlight) for TextArea {
    self.content.remove(row)
    self.update(Change(row, REMOVE), highlight)
}

impl updateContent(self, newContent) for TextArea {
    self.content = newContent
    self.update(null, true)
}

impl update(self, change, highlight: Bool) for TextArea {
    self.render(change)
    if highlight {
        self.highlight(change)
    }
}

impl setListener(self, cursor) for TextArea {
    each line, row of self.references {
        line.listen("click", handleClick(self, cursor, row))
    }
}

func handleClick(textArea, cursor, row) {
    return func(event) {
        @col = (event.location.x / 9.906).int(0.5)
        if col > self.content.get(row).size() {
            col = self.content.get(row).size() + 1
        }
        cursor.detach()
        cursor.move(row, col)
        cursor.render(self.references)
    }
}
